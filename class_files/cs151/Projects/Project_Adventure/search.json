[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "groups.html",
    "href": "groups.html",
    "title": "Group Work",
    "section": "",
    "text": "Because large projects like this one typically involve more than one programmer, you are encouraged to work on this project in teams of two, although you are free to work individually as well. Each person in a two-person team will receive the same grade.\nWhile most pairs will likely want to work on the code together, in person, there are good resources at your disposal that can help should you would want to work more remotely. If you work in a pair, you will both have access to a shared repository on GitHub. This means that, as long as you are good about uploading your files, each person can usually work on the latest version of the code without too much issue. There are some built in ways within VSCode that you can sync your local files with GitHub files as well, so let your instructor know if you’d like some guidance in setting that up. VSCode also has a remote sharing extension, which can essentially give you collaborative control over your code, similar to Google docs. The extension is called “Live Share” if you want to search for it within the VSCode extensions.",
    "crumbs": [
      "Group Work"
    ]
  },
  {
    "objectID": "introduction/overview_files.html",
    "href": "introduction/overview_files.html",
    "title": "Overview of the data files",
    "section": "",
    "text": "Like the teaching machine program, the Adventure program you create for this project is entirely data driven. The program itself does not know the details of the game geography, the items that are distributed across the various rooms, or even the words used to move from place to place. All such information is supplied in the form of data files, which the program uses to control its own operation. If you run the program with different data files, the same program will guide its players through different sets of rooms that presumably have different interconnections, items, and puzzles.\nThe starting repository includes data files for three different adventures of varying sizes. The smallest of these is the Tiny adventure, which describes an adventure with four rooms and no items. The largest is the Crowther adventure, which includes a relatively sizable subset of Will Crowther’s original Adventure game. In between those extremes is the Small adventure, which includes examples of the main features in the game in a space containing just 12 rooms. You should use the Tiny adventure until you get to Milestone 4. After that, you should use the Small adventure whenever you are debugging. Once you have got things working, you can move on to the Crowther adventure.\nTo indicate which data files you would like to use, the Adventure.py program defines a constant called DATA_FILE_PREFIX, which identifies the string that appears at the beginning of the filenames used for that adventure. To get the adventure game illustrated in the earlier examples in this section, DATA_FILE_PREFIX is set to \"Crowther\", which selects the collection of files associated with a large chunk of Will Crowther’s original Adventure game. For each adventure, there are three associated data files that contain the name of the adventure as a prefix. For the Crowther adventure, for example, these files are:\nThese data files are not Python programs, but are instead text files that describe the structure of a particular adventure game in a form that is easy for game designers to write. The Adventure program reads these files into an internal data structure, which it then uses to guide the player through the game.",
    "crumbs": [
      "Overview of the data files"
    ]
  },
  {
    "objectID": "introduction/overview_files.html#sec-rooms",
    "href": "introduction/overview_files.html#sec-rooms",
    "title": "Overview of the data files",
    "section": "The Rooms file",
    "text": "The Rooms file\nThe Rooms file contains the names and descriptions of the rooms along with the passages that connect them. The contents of TinyRooms.txt, for example, are shown below in Figure 1.\n\n\n\n\n\n\nFigure 1: The TinyRooms.py text file, which contains the details about what rooms exist in the adventure and how they are connected to one another.\n\n\n\nThe first thing to notice about the TinyRooms.txt data file is that it matches almost exactly the format used for the teaching machine application. The only real difference is that each room includes a one-line short description as well as the multi-line text. When you implement the code to read the data file for the rooms, you will have to make a few small changes to accommodate this difference. The more substantial part of revising the implementation, however, lies in making sure that the names of all the variables and methods match the metaphor of the Adventure game and not the teaching machine. It would certainly confuse anyone looking at your code to see names like questions and answers! In the context of the Adventure game, the code needs to refer to rooms and passages instead.",
    "crumbs": [
      "Overview of the data files"
    ]
  },
  {
    "objectID": "introduction/overview_files.html#sec-items",
    "href": "introduction/overview_files.html#sec-items",
    "title": "Overview of the data files",
    "section": "The Items file",
    "text": "The Items file\nAlthough you will not need to think about this file until you get to Milestone 4, both the Small and Crowther adventures define a set of items that are distributed somewhere in the cave, such as the keys you saw in the earlier example. Like the rooms, the items in the game are specified using a data file, such as the one for the Small adventure shown in Figure 2.\n\n\n\n\n\n\nFigure 2: The SmallItems.txt data file, which contains information about the available items that can appear in the rooms and where they would initially appear.\n\n\n\nThe contents of the Items file consist of a series of three-line entries, one for each item. The first line is the name of the item, which is also the word that the player uses to refer to the item. The second is a short description of the item, usually beginning with an article like a or an. The third is the name of the room in which the item is placed at the beginning of the game. For example, the lines\nKEYS\na set of keys\nInsideBuilding\ndefine an item whose name is \"KEYS\" and whose description is \"a set of keys\". At the beginning of the game, that item is placed in the room whose identifying name is \"InsideBuilding\", which is precisely where you saw it in the sample runs shown in the earlier section.\nThe last entry in the SmallItems.txt data file illustrates a feature than requires special handling. The lines\nWATER\na bottle of water\nPLAYER\nspecify that the bottle of water starts off in the player’s possession. You will have to check for this case in the code that distributes the items, starting in Milestone 3.",
    "crumbs": [
      "Overview of the data files"
    ]
  },
  {
    "objectID": "introduction/overview_files.html#sec-synonyms",
    "href": "introduction/overview_files.html#sec-synonyms",
    "title": "Overview of the data files",
    "section": "The Synonyms file",
    "text": "The Synonyms file\nThe last data file is the Synonyms file, which consists of a sequence of definitions that allow the player to use more than one word to refer to a direction or an item. The SmallSynonyms.txt file in Figure 3, for example, defines BOTTLE as a synonym for WATER, since both nouns appear in the description. It also defines abbreviated forms of the standard directions so that the player can type N instead of NORTH, along with a few equivalent words for verbs like TAKE and DROP.\n\n\n\n\n\n\nFigure 3: The SmallSynonyms.txt data file, which includes alternative commands or item labels that can be used within the game.",
    "crumbs": [
      "Overview of the data files"
    ]
  },
  {
    "objectID": "milestones/milestone3.html",
    "href": "milestones/milestone3.html",
    "title": "MS 3: Reading and distributing items",
    "section": "",
    "text": "The most important extension that separates the Adventure game from the teaching machine application is the introduction of items like keys and treasures. The items are specified in the Items file described here. For example, the first item in the SmallItems.txt data file is the set of keys, for which the description consists of the following three lines:\nKEYS\na set of keys\nInsideBuilding\nYour first task in this milestone is to implement the AdvItem class, which is given to you in skeletal form in the repository. The AdvItem class defines a constructor and the getter methods get_name, get_description, and get_initial_location, along with a read_item function that reads an item from a data file. Your model for this file is the AdvRoom class, which implements the same mechanism for the more complicated data structure used for rooms. Reading in the information for the items should be significantly more simple. You also will then need to add the necessary code to the AdvGame class to read in all the items at the start and store them in a dictionary, just as you do for the rooms. It is not an error if the Items file is missing; a missing file just means that there are no items.\nYour second task is to add methods to the AdvRoom class so that rooms can keep track of the items they contain. The easiest strategy for doing so is to keep track of the names of the items in the room using a Python set stored in the AdvRoom object as an attribute. In keeping with the principles of data abstraction, clients should not look at this set directly but should instead obtain information through method calls. The following methods are sufficient to get you through all the milestones:\n\nAn add_item method that takes an item name and adds it to the room contents.\nA remove_item method that takes an item name and removes it from the contents.\nA contains_item method that checks whether an item name is in the room.\nA get_contents method that returns a copy of the set of item names.\n\nThe third task is to add code to AdvGame so that it places the items in the appropriate rooms at the start of the game. You could do this either at the end of the constructor once the rooms and items have been read in, or at the start of the run method. This code should iterate through the dictionary containing all the items and then call add_item to put it in the room specified by its initial location. Your code should simply skip over any items whose location is PLAYER until you implement Milestone 4.\nThe fourth and final task is to extend the code that describes a room so that it also prints out the descriptions of the items contained in that room. The items are listed on single lines, one for each item that the room contains.\nBecause Milestone 3 does not yet allow you to pick up and drop items, the only thing you can do to test whether this part is working is to check and see whether the items are listed as part of the room descriptions. For example, you should make sure that the keys are listed inside the building, as shown in the following session:",
    "crumbs": [
      "MS 3: Reading and distributing items"
    ]
  },
  {
    "objectID": "milestones/milestone4.html",
    "href": "milestones/milestone4.html",
    "title": "MS 4: Action Verbs: TAKE, DROP, and INVENTORY",
    "section": "",
    "text": "The next step is to add the TAKE, DROP, and INVENTORY action verbs to the command processor you implemented for Milestone 2. The TAKE verb checks to see if an item is in the room, and if so, removes it from the room and adds it to the player’s inventory. The DROP verb reverses the process, removing an item from the player’s inventory and then adding that item to the room. The INVENTORY verb goes through the player’s inventory and prints the description of each item. If the player’s inventory is empty, the INVENTORY command should display the string \"You are empty-handed.\". These behaviors are illustrated in the following sample run from the beginning of the game:\n\nImplementing this milestone requires several steps:\n\nAdd a new attribute to the AdvGame class that keeps track of the set of items the player is carrying.\nImplement the special case for \"PLAYER\" in the code you wrote for Milestone 3. This should be easy now that you just created the above attribute to store such things.\nWrite code to implement the TAKE, DROP, and INVENTORY commands. Note that TAKE and DROP require you to read an item name that comes after the action verb. This is made easy using the token scanner, but you could handle it otherwise should you want.",
    "crumbs": [
      "MS 4: Action Verbs: TAKE, DROP, and INVENTORY"
    ]
  },
  {
    "objectID": "milestones/milestone6.html",
    "href": "milestones/milestone6.html",
    "title": "MS 6: Locked passages",
    "section": "",
    "text": "When you modified the teaching machine code for Milestone 0, you presumably defined the structure representing passages to be a dictionary that maps direction names to room names. That is, after all, how the teaching machine worked, and this guide did not give you any reason to change that model.\nUnfortunately, using a dictionary does not quite work for the Adventure game. If you look closely at the list of passages in the SmallRooms.txt and CrowtherRooms.txt, you will discover that certain rooms include the same direction name more than once in the list. For example, the entry for the room above the grate that leads to the underground part of the cave looks like this:\nOutsideGrate\nOutside grate\nYou are in a 20-foot depression floored with bare dirt.\nSet into the dirt is a strong steel grate mounted in\nconcrete.  A dry streambed leads into the depression from\nthe north.\n-----\nNORTH: SlitInRock\nUP: SlitInRock\nDOWN: BeneathGrate/KEYS\nDOWN: MissingKeys\nAs you can see, the motion verb \"DOWN\" appears twice in the list of passages. The first corresponding value ends with a slash and the work KEYS, which indicates that the item whose name is \"KEYS\" is required to traverse this passage. The second has no such modifier, which means that the passage is always available. This definition is an example of a locked passage, which is one that requires the player to be holding a specified item that is called its key. In this case, the key is literally the set of keys that starts off inside the building. If the keys are in the player’s inventory, applying the motion verb DOWN uses the first passage; if not, applying DOWN skips over that passage and follows the one to the room named \"MissingKeys\", which is described in Milestone 7.\nThis new feature requires you to change the implementation of the data structure used to represent passages, since a dictionary does not allow multiple values with the same key. What you need to do is change the data structure used to represent the passages from a dictionary to a list, in which the individual elements of the list are tuples containing three values: the direction name, the name of the destination room, and the key required to traverse the passage (which may be None). The code that moves from one room to another based on the player’s input must loop over and search through the list to find the first option that applies.\nThe changes you need to make for Milestone 6 are in the AdvRoom and AdvGame classes. You will, for example, have to change your implementation of read_room so that it stores the data for the passages in a list rather than a dictionary. The get_passages method in AdvRoom then needs to return a copy of that list. Even if the code for get_passages does not change, you need to update the doc-string so that it correctly describes what the updated method does.\nYou also need to change the way that the run method of AdvGame works, so that it checks to see if the player is carrying the necessary item if the passage specifies one. To do so, it makes sense to write a helper method in AdvGame that finds the next room for a given direction, taking into account any items necessary to traverse locked passages.\nOnce you have implemented this change, you should be able to explore the entire Adventure game, picking up items and using them as keys to get through previously closed passages. You still, however, will not be able to escape if you try to go through a locked passage without the necessary key. For that, you need to implement the final milestone.",
    "crumbs": [
      "MS 6: Locked passages"
    ]
  },
  {
    "objectID": "milestones/milestone2.html",
    "href": "milestones/milestone2.html",
    "title": "MS 2: Action Verbs: QUIT, HELP, and LOOK",
    "section": "",
    "text": "Most of the commands entered by the player are words like WEST or EAST that indicate a passage to another room. Collectively, these words are called motion verbs. Motion verbs, however, are not the only possible commands. The Adventure game allows the player to enter various build-in commands called action verbs. The six action verbs you are required to implement (although you only need to implement QUIT, HELP, and LOOK as part of Milestone 2) are described in Table 1.\n\n\n\nTable 1: The build-in action verbs in the Adventure game.\n\n\n\n\n\n\n\n\n\nAction Verb\nDescription\n\n\n\n\nQUIT\nThis command signals the end of the game. Your program should call the build-in function quit to exit from the program. This will abort any running Python program.\n\n\nHELP\nThis command should print instructions for the game on the console. You need not duplicate the instructions from the starter file exactly, but you should certainly give the users an idea of how your game is played. If you make any extensions, you should describe them in the output of your HELP command so that I can easily see what exciting things I should look for!\n\n\nLOOK\nThis command should type the complete description of the room and its contents, even if the user has already visited the room.\n\n\nINVENTORY\nThis command should list what objects the user is holding. If the user is holding no objects, your program should say so with a message along the lines of “You are empty-handed.”\n\n\nTAKE item\nThis command requires a direct item and has the effect of taking the item out of the room and adding it to the set of items the user is carrying. You need to check to make sure that the item is actually in the room before you let the user take it.\n\n\nDROP item\nThis command requires a direct item and has the effect of removing the item from the set of items the user is carrying and adding it back to the collection of items in the room. You need to check to make sure that the user is carrying the item.\n\n\n\n\n\n\nThe first thing you need to do to implement this milestone is to subdivide the user’s input into individual words. This is a process that the tokenscanner module makes easy, but you can do it manually if you really want. Once you have done so, you need to look at the first word to see if it is one of the action verbs before checking whether it is a motion verb. You then need to implement the first three action verbs. The QUIT command stops the program from reading any more user commands, just as a new room with the name \"EXIT\" does in the code you adapted from the teaching machine. The HELP command prints the contents of the HELP_TEXT constant out to the console, and should not print the room description again immediately after. The LOOK command results in the long description of the current room being printed again.\nOnce you have finished this milestone, your program should be able to produce the following sample run:",
    "crumbs": [
      "MS 2: Action Verbs: QUIT, HELP, and LOOK"
    ]
  },
  {
    "objectID": "milestones.html",
    "href": "milestones.html",
    "title": "Introducing Milestones",
    "section": "",
    "text": "For a project of any reasonable complexity, it is important to implement the project in stages rather than trying to get it all going at once. As with all our other projects this semester, this project is organized into a series of milestones designed to lead you through the process in a series of manageable steps.",
    "crumbs": [
      "Introducing Milestones"
    ]
  },
  {
    "objectID": "extensions.html",
    "href": "extensions.html",
    "title": "Possible Extension Ideas",
    "section": "",
    "text": "The following extensions would make the Adventure program much more powerful and would allow the construction of more interesting puzzles and scenarios:\n\nActive items. The biggest weakness in the current game is that the items are entirely passive. All you can do with an item is to pick it up or drop it. Moreover, the only way in which the items enter into the play of the game is in the specification of locked passages in the room data file: if you are carrying an item, some passage is open that would otherwise be locked. It would be wonderful if it were possible to type WAVE WAND or UNLOCK GRATE and have the appropriate thing happen. Moreover, being able to READ or EXAMINE an item adds a lot of interest to the game.\nItem state. In the original version of Adventure, items can have different states. For example, the grate at the entrance to the cave can be either locked or unlocked; similarly, the snake in the Hall of the Mountain King can be blocking your path or driven away. You might add some way to allow the program to keep track of the state of each item and then make it possible for the motion rules to indicate that a particular passage can only be taken if an item is in a certain state: you can go through the grate only if it is unlocked.\nContainment. In Don Wood’s extension to Adventure, some items can contain other items. Putting this concept into the game adds dimensionality to puzzle construction, but also requires implementing prepositional phrases in the parser so that the program can parse such constructions as:\n&gt; PUT NUGGET IN CHEST\nFiller words. The current parser limits the player to using commands that consist of one or two words. Saying:\n&gt; TAKE THE KEYS\ncauses an error because the program does not know the word THE; if the parser ignored articles and other filler words, the program would seem more conversational.\nAdjectives. A similar extension to the parser is the introduction of adjectives that allow the player to issue commands like:\n&gt; TAKE BLACK ROD\nIn the classic Adventure game, adjectives are associated uniquely with the noun to which they refer. In Zork, on the other hand, adjectives were used to differentiate many different items of the same name, so that there could be both a black rod and a green rod in the same game.\nConvenient shortcuts for “all” and “it”. When you are in a room with many items, it is extremely useful to be able to type\n&gt; TAKE ALL\nto take all the items at that location. Similarly, the conversation flows more smoothly if you can refer to the last mentioned item as IT.\nRandom passages. There are several rooms in the original Adventure game at which the motion through a passage is probabilistic. You could implement this sort of feature by specifying a percentage chance on a locked passage rather than an item. Thus, if the data for a room specified the passage entries:\nSOUTH : RoomA/30\nSOUTH : RoomB\nmoving south would go to RoomA 30 percent of the time and to RoomB the rest of the time. (The program can differentiate this specification syntax from the traditional locked passages because the percentage chance starts with a digit, vs a alphabetical character for a key.)",
    "crumbs": [
      "Extensions",
      "Possible Extension Ideas"
    ]
  },
  {
    "objectID": "milestones/milestone5.html",
    "href": "milestones/milestone5.html",
    "title": "MS 5: Synonyms",
    "section": "",
    "text": "At this point in your implementation, your debugging sessions will have you wandering through the Adventure game more than you did in the beginning. As a result, you will almost certainly find it convenient to implement the synonym mechanism, so that you can type N, S, E, and W instead of the full names for the compass directions. The format of the Synonyms file is described here.\nTo implement the synonym processing, you need to read through the Synonyms file and create a dictionary attribute in the AdvGame class that contains the synonym definitions. Then, whenever you read a word–which might be a motion verb, an action verb, or the name of an item–you need to see if that word exists in the synonym dictionary and, if so, substitute the standard definition before continuing with your program.\nAs the with the Items file, it is not an error if the Synonyms file is missing. In that case, the synonym dictionary should just be empty.",
    "crumbs": [
      "MS 5: Synonyms"
    ]
  },
  {
    "objectID": "milestones/milestone0.html",
    "href": "milestones/milestone0.html",
    "title": "MS 0: Modifying the Teaching Machine",
    "section": "",
    "text": "As you may have seen in lecture, the TeachingMachine.py program works as a rudimentary Adventure-style game if you simply change the data file. The results of doing so, however, does not constitute a useful basis for building up a more sophisticated Adventure game. If nothing else, the metaphors used in the code are entirely inappropriate to the new context. The teaching machine program talks about courses, questions and answers, none of which make sense in the Adventure world. The corresponding concepts in Adventure are games, rooms, and passages. Your first step is to take the code for the teaching machine and adapt it so that it makes sense for the Adventure-game model.\nYou have two starting points for this phase of the project. The TeachingMachine folder contains the code for the teaching machine application presented in class. The main repository folder contains the starter versions of the files you need in order to implement the Adventure classes used in the Adventure game. Your task for this milestone is to adapt the code from the TMCourse.py and TMQuestion.py files into their AdvGame.py and AdvRoom.py counterparts (you do not have to do anything with AdvItem.py until Milestone 3).\nThe code you need to complete this milestone is almost entirely there already, at least in a functional sense. All you have to do is copy the code from the teaching machine application into the corresponding classes in the Adventure game, changing the names of the fields and methods so that they fit the Adventure game metaphor and making the small changes discussed here. The new names of the exported methods are given to you as part of the starter files, but you will also need to change the names of a few variables so that they make sense in the context of the game.\nThis milestone has two primary purposes:\n\nTo ensure that you understand what is going on in the teaching machine application.\nTo give you some practice in debugging. Even though the structure of the code remains exactly the same, this milestone is not as easy as you might think. Indeed, many students consider it one of the most difficult! Nearly all the variable and method names will have to change, and you will need to be careful to make sure that your changes are consistent. Since you will probably make some mistakes along the way, you will need to polish up your debugging skills to figure out what exactly you did wrong or missed.\n\n\n\n\n\n\n\nWarning\n\n\n\nThere are two important differences that you should be aware of!\n\nAdvRoom objects have 4 pieces of information associated with them, whereas TMQuestion objects only had three. You need to account for that, both in the constructor and in the read_room function.\nIn the teaching machine example, the read_course function was used to read in and construct the original TMCourse object. If you look at Adventure.py however, you will note a similar model is not being employed here. Instead, the AdvGame class will open the necessary files directly in its constructor function, and that constructor is passed the file prefix as an argument. This is more convenient since you will need to eventually load multiple different files using the same prefix, and so it makes more sense to handle this all within the AdvGame constructor instead of a separate function. Note that you will still need to read in all the game and room information, just like was done in the teaching machine function, but in this case you will want to set the needed attributes directly in the constructor.\n\n\n\nWhen you finish this milestone, you should be able to wander a bit around the surface of the Adventure world, heading up to the top of the hill, inside the building, and down to the grate. You will not, unfortunately, be able to get past this grate until Milestone 6.",
    "crumbs": [
      "MS 0: Modifying the Teaching Machine"
    ]
  },
  {
    "objectID": "milestones/milestone1.html",
    "href": "milestones/milestone1.html",
    "title": "MS 1: Short descriptions",
    "section": "",
    "text": "The Adventure game would be tedious to play–particularly when output devices were as slow as they were in the 1970s–if the program always gave the full description of the room every time you entered it. Crowther’s game introduced the idea of short descriptions, which were one-line descriptions for rooms that the player has already visited. The long description appears the first time a room is entered or when the player types LOOK, and the short description appears thereafter.\nYour job in this milestone is to implement this feature in your program. You presumably already implemented the get_short_description method in the AdvRoom class, but you need to add two new methods to AdvRoom to keep track of whether the room has been visited and change the code in AdvGame so that it checks for that condition and prints out the short description for rooms the player has already seen. The new methods in the AdvRoom class are set_visited and has_been_visited. The first takes a boolean value and stores that as a room attribute indicating whether the room has been visited. The second is just a getter method that returns the value of that attribute.\nOnce you have added these methods, you can add to and tweak your run method in AdvGame to set the visited state of each room as the player encounters it. And before displaying any description, you can check the visited state of the room to see whether the short or long description should be displayed. Once you have accomplished this, your program should be able to generate the following sample run:\n\nNote that the player sees the short description after returning to the initial room.",
    "crumbs": [
      "MS 1: Short descriptions"
    ]
  },
  {
    "objectID": "milestones/milestone7.html",
    "href": "milestones/milestone7.html",
    "title": "MS 7: Forced motion",
    "section": "",
    "text": "When the player tries to go through a locked passage without the necessary key, the game has to indicate that the motion is prohibited. One possible strategy would be to design a whole new data structure to represent messages of this type. A simpler way, however, is to make a small extension to the structure that is already in place.\nWhen Willie Crowther faced this problem in his original Adventure game, he chose the simple approach. He simply created new rooms whose descriptions contained the necessary messages he wanted to deliver. When the player entered one of those rooms, the code that you have been running all along would print out the necessary message, just like any other room description. The only problem is that you don’t actually want the player to end up in that room, but rather to be moved automatically to some other room. To implement this idea, Crowther came up with the idea of using a special motion verb called \"FORCED\" to specify forced motion.\nWhen the player enters a room in which one of the connections is associated with the motion verb FORCED (and the player is carrying any object that the FORCED verb requires to unlock the passage), your program should display the description of that room and then immediately move the player to the specified destination, without waiting for the player to enter any input. This feature makes it possible to display a message to the player and then continue on from there.\nThe facility is illustrated by the room named \"MissingKeys\", which has the following definition:\nMissingKeys\n-\nThe grate is locked and you don't have any keys.\n-----\nFORCED: OutsideGrate\nThe effect of this definition is to ensure that whenever the player enters this room, after printing the message, the room will automatically be set to \"OutsideGrate\", without the player doing anything.\nIt is possible for a single room to use both the locked passage and forced motion options. The CrowtherRooms.txt file, for example, contains the following entry for the room just north of the curtain in the building:\nCurtain1\n-\n-----\nFORCED: Curtain2/NUGGET\nFORCED: MissingTreasures\nThe effect of this set of motion rules is to force the player to the room named Curtains2 if the player is carrying the nugget and to the room named MissingTreasures otherwise. When you are testing your code for locked and forced passages, you might want to pay particular attention to the last eight rooms in the CrowtherRooms.txt file. These rooms, all of which have no lines at all in their long description, implement the shimmering curtain that marks the end of the game.\n\n\n\n\n\n\nWarning\n\n\n\nYou should notice that the rooms with forced motions do not supply a meaningful short description, although the data files use a single hyphen so that the code to read the file still works. Forced motion should always display the long description. Also, be aware that sometimes several forced rooms can be chained together, so it is not enough to just check for a single forced room at a time.\n\n\nOnce you have this working, congratulations! You have a working Adventure game! While you may be sick of wandering around the rooms at this point, I highly suggest you put in some time to play the \"Crowther\" prefix of the game and try to beat it. Doing so will often reveal several issues that you thought were fine but show up in certain circumstances.",
    "crumbs": [
      "MS 7: Forced motion"
    ]
  },
  {
    "objectID": "introduction/overview_game.html",
    "href": "introduction/overview_game.html",
    "title": "Overview of the Adventure Game",
    "section": "",
    "text": "The Adventure game you will implement for this project–like any of the text-based adventure games that were the dominant genre before the advent of more sophisticated graphical adventures like the Myst series–takes place in a virtual world in which you, as the player, move about from one location to another. The locations, which are traditionally called rooms even though they may be outside, are described to you through a written textual description that gives you a sense of the geography. You move about in the game by giving commands, most of which are simply an indication of the direction of the motion. For example, in the classic Adventure game developed by Willie Crowther, you might move about as follows:\n\nIn the console sessions shown in this guide, user input appears in uppercase so that it is easier to see. Your program should ignore case distinctions in executing commands.\nIn this example, you started outside the building, followed the road up the hill by typing WEST, and arrived at a new room on the top of the hill. Having no obvious places to go once you got there, you typed EAST to head back to where you started. As is typical in such games, the complete description of a location appears only the first time you enter it. The second time you come to the building, the program displays a much shorter identifying tag, although you can get the complete description by typing LOOK, as follows:\n\nFrom here, you might decide to go inside the building by typing IN, which brings you to another room, as follows:\n\nIn addition to the new room description, the inside of the building reveals that the Adventure game also contains items: there is a set of keys here. You can pick up the keys by using the TAKE command, which requires that you specify what item you are taking, like so:\n\nThe keys will, as it turns out, enable you to get through a grating at the bottom of the streambed that opens the door to Colossal Cave and the magic it contains.\nThe best model for the Adventure project is the teaching machine example that appears in Chapter 12. The starting repository for Project 5 includes the code for the teaching machine so that you can copy and adapt whatever parts of the code you think will be useful. The repository also includes the tokenscanner library, the various data files described later in this handout, and the following template files for the adventure game:\n\nAdventure.py –This file defines the Adventure function, which is just a few lines long and looks almost exactly the same as the TeachingMachine.py file in the example. The complete code for Adventure.py is given to you in the repository, and you should not need to change anything in this file except for the definition of the ADVENTURE_PREFIX constant when you want to work with other data files–or write your own.\nAdvGame.py –This file defines the AdvGame class, which implements the game and is therefore analogous to the TMCourse class in the teaching machine. In a slight tweak to how it was done in the teaching machine, the AdvGame class constructor will be responsible for reading the various files and storing the information in a suitable internal structure (no need for the extra function here, though much of its contents will be moved inside the constructor). This class also exports the run method, which is called by the Adventure function to start the game. Although the run method is complex–and certainly complex enough to warrant decomposition–you will have a chance to build it up gradually as you go through the milestones.\nAdvRoom.py –The file defines the AdvRoom class, which represents a single room in the game and is analogous to the TMQuestion class in the teaching machine. The repository contains the header lines for the methods you need for Milestone 1. As you move on to later milestones, you will need to add a few more methods as described later in this guide.\nAdvItem.py –This file defines the AdvObject class, which represents an item in the game. This file specifies the header lines for the methods that AdvItem supports. You will have a chance to implement these methods in Milestone 3.",
    "crumbs": [
      "Overview of the Adventure Game"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Project 5: Adventure",
    "section": "",
    "text": "Welcome to the final project of CS 151! Your mission in this project is to write a simple text-based adventure game in the tradition of Will Crowther’s pioneering “Adventure” program of the early 1970s, which was described in class. In games of this sort, the player wanders around from one location to another, picking up items, and solving simple puzzles. The program you will create for this project is less elaborate than Crowther’s original game and is therefore a bit more limited in terms of the types of puzzles one can construct for it. Even so, you can still write a program that captures much of the spirit and flavor of the original game.\nAs per usual, you will submit this project through GitHub Classroom, and you can find the link to accept the project and download the initial template files below.\n\nAccept Project in Rembold Class\n\nTo allow for the possibility of partners, everyone will need to make a team when accepting the assignment, even if you are just going to be working on things solo. Once one partner has made the team, the other can join it. If you accidentally join a team you did not mean to, let Professor Rembold know, and they can see about getting you removed so that you can join another. Only join an existing team if you intend to work with that person! It can help if you name your teams based on the expected team member’s names.\n\n\n\n\n\n\nWarning\n\n\n\nIf you are working with a partner from a different lecture section, make sure you both follow the same link to accept the assignment. Either both use the above link, or both use the link to Professor Deutschbein’s assignment acceptance. So long as you both accept the same section, you’ll be able to join the same team. In the end Professor Rembold combines everything to be delivered to the Section Leaders anyway, so which you join does not matter so long as you both join the same."
  }
]